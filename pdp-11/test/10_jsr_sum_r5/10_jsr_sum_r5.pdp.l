000000:		    . = 100                     ; данные располагаются с 100 адреса
000100:		A:  .WORD 34, 12, -1, 66, 0     ; массив (А - константа, равна адресу 100), сумма = 133, так как все числа восьмеричные
	 000034
	 000012
	 177777
	 000066
	 000000
000112:		
000112:		    .=1000                     ; код располагается с 1000 адреса
001000:		main:
001000:			mov #main, sp
	 012706
	 001000
001004:		    mov #A, R2                 ; R2 - адрес начала массива
	 012702
	 000100
001010:		    clr R0                     ; R0 = 0
	 005000
001012:		    mov #21, R5                ; убедитесь в конце, что этот регистр имеет это же значение
	 012705
	 000021
001016:		    clr R4                     ; сюда будем суммировать все значения R5, чтобы хитрые студенты не игноровали R5 в jsr
	 005004
001020:		    jsr R5, sum
	 004567
	 000002
001024:		    halt
	 000000
001026:		    
001026:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
001026:		; RECURSIVELY sum 1 data in the A array and store the sum into R0
001026:		;    R0 - sum
001026:		;    R2 - address
001026:		;    R3 - (byte)A[R1]
001026:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
001026:		sum:
001026:		    add R5, R4                 ; суммy всех значений R5 сохраним в R4
	 060504
001030:		    mov (R2)+, R3              ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
	 012203
001032:		    beq END                    ; дошли до 0 и дальше в рекурсию не углубляемся
	 001403
001034:		    add R3, R0                 ; очередное число прибавляется к текущей сумме
	 060300
001036:		    jsr R5, sum                ; следующий вызов функции должен суммировать следующее число
	 004567
	 177764
001042:		END:    
001042:		    rts R5
	 000205
