000000:		; expected:
000000:		;
000000:		;
000000:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000:		; Реализовать команду mul 
000000:		; Двоичный код: 0 111 000 rrr sss sss
000000:		; Формат ассемблера: mul src, reg
000000:		; Содержимое 16-битового регистра reg умножается на содержимое 
000000:		; 16-битового источника src, что дает 32-битовый результат в регистрах
000000:		; reg и reg|1.
000000:		; Если номер регистра reg нечетный (то есть reg == reg|1), то 
000000:		; результатом будет 16-битовый результат в reg, старшие 16 бит 
000000:		; результата будут потеряны. (Если произведение достаточно велико,
000000:		; чтобы в случае нечетного регистра терялись биты, то будет установлен
000000:		; бит С в PSW).
000000:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000:		; Тест 0
000000:		; 123 * 456 = 60 752
000000:		; Тест 1 - реализован
000000:		; 12345 * 54321 = 717743365
000000:		; bin: 111001111111100011011110101
000000:		; bin: 0 000 011 100 111 111 % 1 100 011 011 110 101
000000:		; oct: 0   0   3   4   7   7   1   4   3   3   6   5
000000:		; Тест 2 (с переполнением)
000000:		; 123456*654321 = ‭105 742 446 216‬
000000:		; bin: ‭0010 % 0 010 111 110 001 010 % 0 100 110 010 001 110‬
000000:		; oct:   1  % 0   2   7   6   1   2 % 0   4   6   2   1   6
000000:		; bin: ‭00100010111110 001 010 0 100 110 010 001 110‬
000000:		
000000:		    .=200
000200:		A:  .WORD  12345,  54321
	 012345
	 054321
000204:		
000204:		    .=1000
001000:		    mov #A, R0      ; R0 = 200
	 012700
	 000200
001004:		    mov (R0)+, R3   ; R3 = 12345, R0 = 202
	 012003
001006:		    mov R3, R4      ; R4 = 12345
	 010304
001010:		    
001010:		    mul (R0), R3    ; R3 = 143365
	 070310
001012:		    mul (R0), R4    ; R4 = 143365, R5=003477
	 070410
001014:		    
001014:		    halt
	 000000
