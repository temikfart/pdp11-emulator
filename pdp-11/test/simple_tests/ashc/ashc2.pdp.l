000000:		; expected:
000000:		; r0=172345 r2=034567 r4=001234 sp=000000
000000:		; r1=156543 r3=054320 r5=156543 pc=001036
000000:		; psw=000010: cm=k pm=k pri=0   n    [11]
000000:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000:		; Реализовать команду ASHC
000000:		; Двоичный код ASHC:  0 111 011 rrr sss sss
000000:		; Формат ассемблера: ASHC src, reg
000000:		; 32-битное слово, состоящее из [reg, reg|1],
000000:		; сдвинуть на n бит влево (n>0) или вправо (n<0),
000000:		; где n - значение шести младших битов src.
000000:		; N, Z - по результату операции
000000:		; C - загружается значением последнего бита, сдвинутого из регистра.
000000:		; V - устанавливается, если в любой момент во время сдвига самый
000000:		; старший бит 32-битного слова изменил свое значение, иначе сбрасывается.
000000:		; 6 младших бит источника берутся со знаком, так что -32 <= n <= 31.
000000:		; При n>=0, то сдвиг влево на n бит. 
000000:		; Самый старший бит 31 сдвигается в С, в самый младший записывается 0.
000000:		; При n<0, то сдвиг вправо на n бит. 
000000:		; Самый младший бит 0 сдвигается в С.
000000:		; Значение освободившегося самого старшего бита 31 воспроизводится.
000000:		; Если номер регистра НЕЧЕТНЫЙ, то 
000000:		; сдвиг влево эквивалентен ASH src, reg
000000:		; сдвиг вправо - ЦИКЛИЧЕСКИЙ (флаг С в него не вовлекается)
000000:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000:		; oct: 123456 165432
000000:		; test1  ash 3
000000:		; bin:   1 010 011 100 101 110 1 110 101 100 011 010 = 123456 165432 << 3, C=1
000000:		; ash: (1) 0 011 100 101 110 111 0 101 100 011 010 000 = 034567 054320 = R2 R3
000000:		; test2  ashc -3 (воспроизводится 0)
000000:		; bin:   0 001 010 011 100 110  1 110 101 100 011 010 = 012346 165432 >> 3, C=0
000000:		; ashc:  0 000 001 010 011 100 1 101 110 101 100 011 = 001234 156543 = R4 R5
000000:		; test3  ash -3 (воспроизводится 1)
000000:		; bin:   1 010 011 100 101 110 1 110 101 100 011 010 = 123456 165432 >> 3, C=0
000000:		; ashc:  1 111 010 011 100 101 1 101 110 101 100 011= 172345 156543
000000:		; test4  ash -3 (первые 6 бит со знаком)     01 111 101 = 175
000000:		; как в test3 для четного регистра - в файле 2. 
000000:		; test4  ash -3 (первые 6 бит со знаком)     01 111 101 = 175
000000:		; для нечетного регистра R1
000000:		; bin:   1 010 011 100 101 101 123456 >> 3, C=1
000000:		; ash:   110 1 010 011 100 101 152345
000000:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000:		
000000:		    .=200
000200:		A:  .WORD  123456, 165432
	 123456
	 165432
000204:		
000204:		    .=1000
001000:		    mov #A, R0      ; R0 = 200
	 012700
	 000200
001004:		    mov (R0),  R1   ; R1 = 123456 test 4 for odd reg
	 011001
001006:		    mov (R0)+, R2   ; R2 = 123456 test 4
	 012002
001010:		    mov (R0)+, R3   ; R3 = 165432
	 012003
001012:		                    
001012:		    ashc #175, R2     ; 172345 156543 = R2 R3, C=0
	 073227
	 000175
001016:		    ashc #175, R1     ; 123455 >> 3 = 152345, C=0 (cycle rotation)
	 073127
	 000175
001022:		    
001022:		    halt
	 000000
